/*
 * ImportExcel.java
 *
 * Created on 20 Ιανουάριος 2008, 10:54 πμ
 */
package DirectMail.Tools.File.Import.Forms;

import DirectMail.Help.Components.Errors;
import DirectMail.Help.Functions.DmFunctions;
import DirectMail.Main.MainForm;
import DirectMail.Options.DmOptions;
import soldatos.messages.Messages;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Writer;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Iterator;
import java.util.logging.Level;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileFilter;
import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFDateUtil;
import org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.CellValue;
import soldatos.functions.FileFunctions;

/**
 *
 * @author  ssoldatos
 */
public class ImportExcel extends javax.swing.JFrame implements Runnable {

  FileFilter excelFilter;
  private PrintWriter out;
  private long start;
  private long end;
  private MainForm m;
  private boolean errorError;
  private boolean formulaError;
  HSSFFormulaEvaluator formulaEval;
  private String filename = "";

  /** Creates new form ImportExcel
   * @param m 
   */
  public ImportExcel(MainForm m) {
    this.m = m;
  }

  /** Creates new form ImportExcel with a selected file
   * @param m
   * @param filename The filename to import
   */
  public ImportExcel(MainForm m, String filename) {
    this.m = m;
    this.filename = filename;
  }

  @Override
  public void run() {
    MainForm.glassPane.activate(null);
    excelFilter = new FileFilter() {

      @Override
      public boolean accept(File f) {
        if (f.isDirectory()) {
          return true;
        } else {
          if (f.getName().endsWith(".xls")) {
            return true;
          }
        }
        return false;
      }

      @Override
      public String getDescription() {
        return "Excel File";
      }
    };
    File file = null;
    if (filename.equals("")) {
      initComponents();
      setLocationRelativeTo(null);
      //setVisible(true);
      int r = excelChoser.showOpenDialog(null);
      if (r == JFileChooser.APPROVE_OPTION) {
        file = excelChoser.getSelectedFile();
      } else {
        dispose();

      }
    } else {
      file = new File(filename);
    }
    try {
      //check new xls extractor
      // XlsReader x = new XlsReader(file.getAbsolutePath(), "d:/out.txt");
      // x.readExcel(true);
      // if(true){
      // return;
      // }

      m.setOpenedFile(file.getName());
      m.setCurrentDirectory(file.getParent());
      MainForm.options.setOption(DmOptions.HOME_DIR, file.getParent());

      setVisible(false);
      start = System.currentTimeMillis();
      readExcelFile(file);
      dispose();
    } catch (Exception ex) {
      MainForm.myLog.log(Level.WARNING, null, ex);
    } finally {
      MainForm.glassPane.deactivate();
    }

    end = System.currentTimeMillis();
    m.appendOutput("\nExecution time : " + DmFunctions.execTime(start, end));
    initComponents();
    m.textBoxEncodingIn.setText(m.getEncodingIn());
    m.textBoxEncodingOut.setText(m.getEncodingOut());
    if (m.getEncodingOut().equals("Cp1253") || m.getEncodingOut().equals("windows-1253")) {
      //m.characterSet = "CHARACTER SET greek COLLATE greek_general_ci";
      m.setCharacterSet("greek");
      m.setCollation("greek_general_ci");
    } else {
      m.setCharacterSet("utf8");
      m.setCollation("utf8_general_ci");
    }
    MainForm.glassPane.deactivate();
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    excelChoser = new javax.swing.JFileChooser();

    setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);

    excelChoser.setCurrentDirectory(new File(MainForm.options.toString(DmOptions.HOME_DIR)));
    excelChoser.setFileFilter(excelFilter);
    excelChoser.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        excelChoserActionPerformed(evt);
      }
    });

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addComponent(excelChoser, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addComponent(excelChoser, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
    );

    pack();
  }// </editor-fold>//GEN-END:initComponents
  private void excelChoserActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_excelChoserActionPerformed
  }//GEN-LAST:event_excelChoserActionPerformed
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JFileChooser excelChoser;
  // End of variables declaration//GEN-END:variables

  // End of variables declaration
  @SuppressWarnings("deprecation")
  private void readExcelFile(File f) throws FileNotFoundException, IOException, NullPointerException, NumberFormatException {
    String outLine = "", sampleLines = "";
    String tmpFilename = FileFunctions.createRandomName();
    //int activeSheet = 0;
    m.setOrigFileName(tmpFilename);
    File tmpOpenFile = new File(tmpFilename);
    m.setOrigFile(tmpOpenFile);
    tmpOpenFile.deleteOnExit();
    out = new PrintWriter(DmOptions._JAR_DIR_+"tmp/" + tmpFilename);

    InputStream inp = new FileInputStream(f);
    HSSFWorkbook wb = new HSSFWorkbook(inp);
    int activeSheet = 0;
    String selSheet = "";
    if (wb.getNumberOfSheets() > 1) {
      String[] sheetArray = new String[wb.getNumberOfSheets()];
      for (int i = 0; i < wb.getNumberOfSheets(); i++) {
        HSSFSheet sheet = wb.getSheetAt(i);
        int rows = sheet.getLastRowNum();
        if (rows > 0) {
          rows += 1;
        }
        sheetArray[i] = "Sheet: " + (i + 1) + " (" + rows + " rows)";
      }
      selSheet = (String) JOptionPane.showInputDialog(
          null,
          "Select the sheet to import",
          "Sheet selection",
          JOptionPane.DEFAULT_OPTION,
          null,
          sheetArray,
          sheetArray[0]);
      try {
        activeSheet = Integer.parseInt(selSheet.split(" ", -1)[1]) - 1;
      } catch (NumberFormatException ex) {
        MainForm.glassPane.deactivate();
        throw new NumberFormatException();
      } catch (NullPointerException ex) {
        MainForm.glassPane.deactivate();
        throw new NullPointerException();
      }
    } else {
      activeSheet = 0;
    }
    formulaEval = new HSSFFormulaEvaluator(wb.getSheetAt(activeSheet), wb);
    if (wb.getSheetAt(activeSheet).getLastRowNum() > 0) {
      HSSFSheet sheet = wb.getSheetAt(activeSheet);
      Iterator rows = sheet.rowIterator();
      int numOfCells = sheet.getRow(0).getLastCellNum();
      m.setOutput("Importing Excel File");
      m.setProgressText("Importing Excel File");
      m.IndeterminateProgress(true);
      int lines = 0, cellNo = 0;
      String cellValue = "";
      while (rows.hasNext()) {
        lines++;
        cellNo = 0;
        HSSFRow row = (HSSFRow) rows.next();
        for (int i = 0; i < numOfCells; i++) {
          cellNo++;
          HSSFCell cell = (HSSFCell) row.getCell((short) i);
          cellValue = processCell(cell, row);
          if (cellNo < numOfCells) {
            outLine += cellValue + "\t";
          } else {
            outLine += cellValue;
          }
        }

        if (!outLine.trim().equals("")) {
          if (lines < MainForm.options.toInt(DmOptions.MAX_SAMPLE_LINES)) {
            sampleLines += outLine + "\n";
          }
          out.println(outLine);
          m.setCustomers(lines);

        }
        outLine = "";
      }
      out.close();
      m.setTextAreaText(sampleLines);
      m.init(false);

      InputStream in = new FileInputStream(DmOptions._JAR_DIR_+"tmp/" + tmpFilename);

      tmpFilename = FileFunctions.createRandomName();
      //int activeSheet = 0;
      m.setOrigFileName(tmpFilename);
      tmpOpenFile = new File(tmpFilename);
      m.setOrigFile(tmpOpenFile);
      tmpOpenFile.deleteOnExit();
      OutputStream conv = new FileOutputStream(new File(DmOptions._JAR_DIR_+"tmp/" + tmpFilename));
      // Set up character streams.
      Reader r = new BufferedReader(new InputStreamReader(in, m.getEncodingIn()));
      Writer w = new BufferedWriter(new OutputStreamWriter(conv, m.getEncodingOut()));

      // Copy characters from input to output. The InputStreamReader
      // converts from the input encoding to Unicode, and the
      // OutputStreamWriter converts from Unicode to the output encoding.
      // Characters that cannot be represented in the output encoding are
      // output as '?'
      char[] buffer = new char[4096];
      int len;
      while ((len = r.read(buffer)) != -1) // Read a block of input.
      {
        w.write(buffer, 0, len); // And write it out.
      }
      r.close(); // Close the input.
      w.close(); // Flush and close output.



      m.setProgressText("");
      m.IndeterminateProgress(false);
    } else {
      Errors.customError("No rows", "No rows in the selected sheet");
    }
  }

  private String processCell(HSSFCell cell, HSSFRow curRow) {
    String v = "";
    if (cell == null) {
      return "";
    }
    HSSFCell newCell;
    CellValue value;
    Date date;
    SimpleDateFormat formatter;
    String dateFormat = "dd/MM/yy";

    if (cell.getCellType() == HSSFCell.CELL_TYPE_NUMERIC) {
      if (HSSFDateUtil.isCellDateFormatted(cell)) {
        double ddate = Double.parseDouble(String.valueOf(cell.getNumericCellValue()));
        date = HSSFDateUtil.getJavaDate(ddate);
        formatter = new SimpleDateFormat(dateFormat);
        v = formatter.format(date);
      } else if (cell.getNumericCellValue() == (long) cell.getNumericCellValue()) {
        v = String.valueOf((long) cell.getNumericCellValue());
      } else {
        DecimalFormat myFormatter = new DecimalFormat("0.00");
        v = myFormatter.format(cell.getNumericCellValue());
        //v = String.valueOf(cell.getNumericCellValue());
      }
    } else if (cell.getCellType() == HSSFCell.CELL_TYPE_STRING) {
      v = String.valueOf(cell.getRichStringCellValue());
    } else if (cell.getCellType() == HSSFCell.CELL_TYPE_BOOLEAN) {
      v = String.valueOf(cell.getBooleanCellValue());
    } else if (cell.getCellType() == HSSFCell.CELL_TYPE_BLANK) {
      v = "";
    } else if (cell.getCellType() == HSSFCell.CELL_TYPE_ERROR) {
      if (!errorError) {
        Messages.customError("Error", "There was an error while reading a cell ");
        errorError = true;
      }
      v = "Error";
    } else if (cell.getCellType() == HSSFCell.CELL_TYPE_FORMULA) {
//      if (!formulaError) {
//      Messages.customError("Formula", "There was a formula in a cell ");
//      formulaError = true;
//      }
      formulaEval.setCurrentRow(curRow);
      newCell = formulaEval.evaluateInCell(cell);
      v = processCell(newCell, curRow);
    }
    v = v.replaceAll("\r\n", "\n");
    v = v.replaceAll("\r", "\n");
    v = v.replaceAll("\n", " ");
    return v;
  }
}
